<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="shortcut icon"
      href="../recursos/audio/favicon.ico"
      type="image/x-icon"
    />
    <title>SuperNetos - Perguntas Dinâmicas</title>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Italiana&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap");

      * {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      @font-face {
        font-family: "Material Symbols Rounded";
        font-style: normal;
        font-weight: 400;
        src: url(https://fonts.gstatic.com/s/materialsymbolsrounded/v226/syl0-zNym6YjUruM-QrEh7-nyTnjDwKNJ_190FjpZIvDmUSVOK7BDB_Qb9vUSzq3wzLK-P0J-V_Zs-QtQth3-jOcbTCVpeRL2w5rwZu2rIelXxc.woff2)
          format("woff2");
      }

      .material-symbols-rounded {
        font-family: "Material Symbols Rounded";
        font-weight: normal;
        font-style: normal;
        font-size: auto;
        line-height: 1;
        letter-spacing: normal;
        text-transform: none;
        display: inline-block;
        white-space: nowrap;
        word-wrap: normal;
        direction: ltr;
        font-feature-settings: "liga";
        -moz-font-feature-settings: "liga";
        -moz-osx-font-smoothing: grayscale;
      }

      #screen_rotation_icon {
        font-size: 64px;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background-color: black;
        height: 100%;
        font-family: "Arial Black", Arial, sans-serif;
      }

      #box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        aspect-ratio: 16/9;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        background-image: url("../recursos/imagens/interface/background.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      @media (min-aspect-ratio: 16/9) {
        #box {
          width: auto;
          height: 100vh;
        }

        #overlay {
          display: none;
        }
      }

      @media (max-aspect-ratio: 16/9) {
        #box {
          width: 100vw;
          height: auto;
        }
      }

      .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgb(49, 49, 49);
        color: white;
        text-align: center;
        font-size: 1.5em;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      @media (max-aspect-ratio: 0.999/1) {
        .overlay {
          display: flex;
        }

        #box {
          display: none;
        }
      }

      /* Responsividade para dispositivos móveis pequenos */
      @media (max-width: 768px) and (min-aspect-ratio: 1/1) {
        #background-question-container {
          width: 90vw;
          height: auto;
          min-height: 80vh;
          padding: 2vh;
        }

        #main-question-container {
          width: calc(90vw - 2vh);
          height: auto;
          min-height: 80vh;
          padding: 3vh 2vw;
        }

        #main-content {
          gap: 1.5vh;
          justify-content: space-evenly;
        }

        .question-title-section {
          font-size: 0.7em;
          flex-wrap: wrap;
          margin-bottom: 1vh;
        }

        #question-text {
          font-size: 1.5em;
          margin-top: 0.3em;
          margin-bottom: 0.5em;
          padding: 0 2vw;
          line-height: 1.2;
        }

        .question-audio-button {
          font-size: 2.8em;
        }

        .answer-buttons-section {
          flex-wrap: wrap;
          gap: 1vh;
          margin: 2vh 0;
        }

        .answer-option-text {
          font-size: 1.5em;
          margin: 0.3em 0;
        }

        .answer-button {
          margin: 0.5vw;
          padding: 2.5vw 4vw;
          font-size: 26px;
        }

        .button-separator {
          width: 3vw;
        }

        .question-illustration {
          width: 70vw;
          height: auto;
          min-height: 25vh;
          max-height: 35vh;
          border-width: 0.4vw;
          border-radius: 3vw;
          margin-bottom: 1vh;
        }

        .ai-generated-label {
          font-size: 0.7em;
          padding: 0.5vh 1vw;
          margin-bottom: 0.5vh;
        }

        .character-sidebar {
          width: 18vw;
          height: 36vw;
          min-width: 110px;
          min-height: 130px;
          right: 1.5vw;
          top: 72%;
        }

        .question-counter {
          top: 1.5vw;
          right: 1.5vw;
          padding: 1.8vw 2.8vw;
          border-radius: 1.5vw;
          font-size: 1em;
        }

        .volume-control {
          top: 1.5vw;
          left: 1.5vw;
          width: 12vw;
          height: 12vw;
          min-width: 48px;
          min-height: 48px;
          font-size: 1.3em;
        }
      }

      @media (max-width: 480px) and (min-aspect-ratio: 1/1) {
        #background-question-container {
          width: 95vw;
          height: auto;
          min-height: 85vh;
          padding: 1.5vh;
        }

        #main-question-container {
          width: calc(95vw - 1.5vh);
          height: auto;
          min-height: 85vh;
          padding: 2.5vh 2vw;
        }

        #main-content {
          gap: 1vh;
          justify-content: space-evenly;
        }

        .question-title-section {
          font-size: 0.6em;
          margin-bottom: 0.5vh;
        }

        #question-text {
          font-size: 1.1em;
          padding: 0 3vw;
          line-height: 1.2;
        }

        .question-audio-button {
          font-size: 2.3em;
        }

        .answer-option-text {
          font-size: 1.3em;
        }

        .answer-button {
          padding: 3vw 5vw;
          font-size: 22px;
        }

        .button-separator {
          width: 2vw;
        }

        .question-illustration {
          width: 75vw;
          height: auto;
          min-height: 22vh;
          max-height: 30vh;
          border-width: 0.3vw;
        }

        .ai-generated-label {
          font-size: 0.65em;
        }

        .character-sidebar {
          width: 22vw;
          height: 42vw;
          min-width: 90px;
          min-height: 110px;
        }

        .question-counter {
          font-size: 0.95em;
          padding: 2vw 3.5vw;
        }

        .volume-control {
          width: 13vw;
          height: 13vw;
          min-width: 42px;
          min-height: 42px;
        }
      }

      /* Retângulo de fundo secundário */
      #background-question-container {
        position: absolute;
        width: 65vw;
        height: 45vw;
        border-radius: 4vw;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1;
        transition: background-color 0.3s ease;
      }

      /* Retângulo de fundo principal */
      #main-question-container {
        position: absolute;
        width: calc(65vw - 3vh);
        height: 45vw;
        border-radius: 4vw;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.5) 0%,
          rgba(255, 255, 255, 0) 20%
        );
        box-shadow: 0px 1vw 2vw rgba(0, 0, 0, 0.25);
        transition: background-color 0.3s ease;
      }

      /* Conteúdo principal da pergunta */
      #main-content {
        width: 100%;
        height: 100%;
        border-radius: 4vw;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-weight: bold;
        color: rgba(0, 0, 0, 0.5);
      }

      /* Seção do título com ícone de som - Estilos base */
      .question-title-section {
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 0 0.1vw 0.2vw rgba(0, 0, 0, 0.5);
      }

      /* Media query para desktop - font-size 0.8em apenas em telas grandes */
      @media (min-width: 769px) {
        .question-title-section {
          font-size: 0.8em;
        }
      }

      /* Texto da pergunta - Estilos base */
      #question-text {
        transition: all 0.3s ease;
        font-weight: bold;
        margin-bottom: 0;
        margin-top: 0.4em;
      }

      /* Media query para desktop - font-size 2.5em apenas em telas grandes */
      @media (min-width: 769px) {
        #question-text {
          font-size: 2.5em;
        }
      }

      /* Botão de reprodução de áudio da pergunta - Estilos base */
      .question-audio-button {
        border: none;
        background: none;
        cursor: pointer;
        transition: transform 0.2s ease;
        color: white;
      }

      /* Media query para desktop - font-size 3.5em apenas em telas grandes */
      @media (min-width: 769px) {
        .question-audio-button {
          font-size: 3.5em;
        }
      }

      .question-audio-button:hover {
        transform: scale(1.1);
      }

      .question-audio-button:active {
        transform: scale(0.95);
      }

      /* Seção dos botões de resposta */
      .answer-buttons-section {
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 0 0.1vw 0.2vw rgba(0, 0, 0, 0.5);
      }

      /* Textos das opções de resposta - Estilos base */
      .answer-option-text {
        margin-top: 0;
        margin-bottom: 0.2em;
        font-weight: bold;
      }

      /* Media query para desktop - font-size 1.8em apenas em telas grandes */
      @media (min-width: 769px) {
        .answer-option-text {
          font-size: 1.8em;
        }
      }

      /* Botões de resposta (Pode/Não Pode) - Estilos base */
      .answer-button {
        margin: 1vw;
        padding: 1vw 1vw;
        border-radius: 1vw;
        border: none;
        color: white;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.1s ease;
      }

      /* Media query para desktop - font-size 32px apenas em telas grandes */
      @media (min-width: 769px) {
        .answer-button {
          font-size: 32px;
        }
      }

      .answer-button:hover {
        transform: scale(1.1);
      }

      .answer-button:active {
        transform: scale(0.95);
      }

      /* Espaçador entre botões */
      .button-separator {
        width: 5vw;
      }

      /* Botão "Pode" (positivo) */
      .positive-answer-button {
        background-color: #00c853;
      }

      /* Botão "Não Pode" (negativo) */
      .negative-answer-button {
        background-color: #d50000;
      }

      /* Ilustração da pergunta */
      .question-illustration {
        position: relative;
        margin-bottom: 1vh;
        aspect-ratio: 386/207;
        width: auto;
        height: 60%;
        border-radius: 5vw;
        border-color: rgb(217, 255, 255);
        border-width: 0.4vw;
        border-style: solid;
        background-color: lightgray;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background-image 0.3s ease;
      }

      /* Label indicando que é IA */
      .ai-generated-label {
        font-size: 0.8em;
        color: #292929;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 0.5vh 1vw;
        border-radius: 1vw;
        margin-bottom: 2vh;
        font-style: italic;
        text-align: center;
      }

      /* Personagem no lado direito */
      .character-sidebar {
        position: absolute;
        right: 2vw;
        top: 75%;
        transform: translateY(-50%);
        width: 15vw;
        height: 35vw;
        min-width: 150px;
        min-height: 180px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        z-index: 5;
        border-radius: 2vw;
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        transition: transform 0.3s ease;
      }

      .character-sidebar:hover {
        transform: translateY(-50%) scale(1.05);
      }

      /* Contador de pergunta - Estilos base */
      .question-counter {
        position: absolute;
        top: 2vw;
        right: 2vw;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 1vw 2vw;
        border-radius: 2vw;
        font-weight: bold;
        z-index: 10;
      }

      /* Media query para desktop - font-size 1.2em apenas em telas grandes */
      @media (min-width: 769px) {
        .question-counter {
          font-size: 1.2em;
        }
      }

      /* Controle de volume discreto - Estilos base */
      .volume-control {
        position: absolute;
        top: 2vw;
        left: 2vw;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 4vw;
        height: 4vw;
        min-width: 50px;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.3s ease;
        z-index: 10;
      }

      /* Media query para desktop - font-size 1.5em apenas em telas grandes */
      @media (min-width: 769px) {
        .volume-control {
          font-size: 1.5em;
        }
      }

      .volume-control:hover {
        background-color: rgba(0, 0, 0, 0.8);
      }

      /* Animação de transição */
      .fade-transition {
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .fade-transition.show {
        opacity: 1;
      }

      /* Sistema de balão de fala */
      .speech-bubble-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        cursor: pointer;
      }

      .speech-bubble-container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2vw;
        max-width: 80vw;
        flex-direction: row;
      }

      .character-image {
        width: 35vw;
        height: 35vw;
        min-width: 250px;
        min-height: 250px;
        max-width: 400px;
        max-height: 400px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        border-radius: 15px;
        animation: characterBounce 2s infinite ease-in-out;
      }

      @media (max-width: 768px) {
        .speech-bubble-container {
          flex-direction: column;
          gap: 3vw;
        }

        .speech-bubble {
          max-width: 70vw;
        }

        .speech-bubble::before {
          left: 50%;
          top: -20px;
          transform: translateX(-50%);
          border-left: 20px solid transparent;
          border-right: 20px solid transparent;
          border-bottom: 20px solid white;
          border-top: none;
        }
      }

      @keyframes characterBounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .speech-bubble {
        position: relative;
        background: white;
        border-radius: 20px;
        padding: 30px;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        animation: bubbleAppear 0.5s ease-out;
      }

      @keyframes bubbleAppear {
        0% {
          opacity: 0;
          transform: scale(0.8) translateY(20px);
        }
        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .speech-bubble::before {
        content: "";
        position: absolute;
        left: -20px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-top: 20px solid transparent;
        border-bottom: 20px solid transparent;
        border-right: 20px solid white;
      }

      .speech-text {
        font-weight: bold;
        color: #333;
        text-align: center;
        margin: 0;
        line-height: 1.3;
      }

      /* Media query para desktop - font-size 1.8em apenas em telas grandes */
      @media (min-width: 769px) {
        .speech-text {
          font-size: 1.8em;
        }
      }

      .speech-text.success {
        color: #4caf50;
      }

      .speech-text.error {
        color: #f44336;
      }

      .click-hint {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.9em;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
        }
        50% {
          opacity: 1;
        }
      }

      /* Overlay invisível para carregar JSON */
      .invisible-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: transparent;
        z-index: 3000;
        cursor: pointer;
        display: none;
      }

      /* Overlay invisível para fullscreen */
      .fullscreen-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: transparent;
        z-index: 3000;
        cursor: pointer;
        display: none;
      }
    </style>
  </head>

  <body>
    <audio id="bg-music" src="../recursos/audio/Heroic.mp3" loop></audio>

    <div class="overlay">
      <span class="material-symbols-rounded" id="screen_rotation_icon"
        >screen_rotation</span
      >
      <p>Vire a tela na horizontal</p>
    </div>

    <div id="box">
      <div class="question-counter">
        <span id="current-question">1</span> /
        <span id="total-questions">5</span>
      </div>

      <button
        class="volume-control"
        id="volumeBtn"
        title="Controlar música de fundo"
      >
        <span class="material-symbols-rounded" id="vol-icon">volume_off</span>
      </button>

      <div id="main-question-container">
        <div id="main-content">
          <div class="question-title-section">
            <button
              class="question-audio-button"
              id="question-audio-btn"
              title="Clique para ouvir a pergunta"
            >
              <span class="material-symbols-rounded" id="speak-icon"
                >volume_up</span
              >
            </button>
            <p id="question-text">Carregando...</p>
          </div>

          <div class="answer-buttons-section">
            <button
              class="answer-button positive-answer-button"
              id="positive-answer-btn"
            >
              <span class="material-symbols-rounded">thumb_up</span>
            </button>
            <p id="positive-answer-text" class="answer-option-text">SIM</p>
            <div class="button-separator"></div>
            <button
              class="answer-button negative-answer-button"
              id="negative-answer-btn"
            >
              <span class="material-symbols-rounded">thumb_down</span>
            </button>
            <p id="negative-answer-text" class="answer-option-text">NÃO</p>
          </div>

          <div class="question-illustration" id="question-illustration"></div>
          <div class="ai-generated-label">
            Imagem criada por inteligência artificial
          </div>
        </div>
      </div>

      <!-- Personagem no lado direito -->
      <div class="character-sidebar" id="character-sidebar"></div>

      <div id="background-question-container"></div>
    </div>

    <!-- Sistema de balão de fala -->
    <div class="speech-bubble-overlay" id="speech-overlay">
      <div class="speech-bubble-container">
        <div class="character-image" id="character-image"></div>
        <div class="speech-bubble">
          <p class="speech-text" id="speech-text">Texto do balão</p>
        </div>
      </div>
      <div class="click-hint">
        Clique em qualquer lugar ou pressione Enter para continuar
      </div>
    </div>

    <!-- Overlay invisível para carregar JSON -->
    <div class="invisible-loader" id="invisible-loader"></div>

    <!-- Overlay invisível para fullscreen -->
    <div class="fullscreen-overlay" id="fullscreen-overlay"></div>

    <!-- Input file invisível para contornar CORS -->
    <input
      type="file"
      id="json-file-input"
      accept=".json"
      style="display: none"
    />

    <script>
      let perguntasConfig = [];
      let perguntaAtual = 0;
      let pontuacao = 0;
      let totalAttempts = 0;
      let personagemEscolhido = null; // menino ou menina
      let aguardandoProximaPergunta = false;

      // Sistema de motivação e selos
      let perguntasRespondidas = 0; // Total de perguntas respondidas (incluindo repetidas)
      let perguntasUnicas = 0; // Perguntas únicas para conquista de selos
      let selosConquistados = [];

      // Frases motivacionais
      const frasesMotivacionais = [
        "Parabéns! Você está se tornando um verdadeiro SuperNeto! 🌟",
        "Excelente progresso! Continue assim, campeão! 🏆",
        "Incrível! Você está aprendendo muito sobre cuidar dos idosos! 💪",
        "Fantástico! Sua sabedoria está crescendo a cada pergunta! 🧠",
        "Impressionante! Você é um exemplo de respeito aos idosos! ❤️",
        "Brilhante! Continue nessa jornada de aprendizado! ✨",
        "Maravilhoso! Você está dominando a arte de ser um SuperNeto! 🎯",
        "Sensacional! Sua dedicação é inspiradora! 🌈",
      ];

      // URL do JSONBin com suas perguntas
      const JSONBIN_URL =
        "https://api.jsonbin.io/v3/b/68dedd45ae596e708f04019b";

      // ========== SISTEMA DE TEXT-TO-SPEECH (TTS) ==========
      let vozesDisponiveis = [];
      let vozSelecionada = null;
      let ttsHabilitado = true;

      // Inicializar vozes disponíveis
      function inicializarVozes() {
        vozesDisponiveis = window.speechSynthesis.getVoices();

        // Selecionar melhor voz em português
        vozSelecionada =
          vozesDisponiveis.find(
            (v) => v.lang === "pt-BR" && v.name.includes("Google")
          ) ||
          vozesDisponiveis.find((v) => v.lang === "pt-BR") ||
          vozesDisponiveis.find((v) => v.lang.startsWith("pt")) ||
          vozesDisponiveis[0];

        console.log(
          "Voz selecionada:",
          vozSelecionada?.name || "Padrão do sistema"
        );
      }

      // Carregar vozes (alguns navegadores carregam de forma assíncrona)
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = inicializarVozes;
      }
      setTimeout(inicializarVozes, 100);

      // Função para falar texto usando Web Speech API
      function falarTexto(texto, opcoes = {}) {
        if (!ttsHabilitado) return;

        // Cancelar qualquer fala anterior
        window.speechSynthesis.cancel();

        // Limpar emojis e caracteres especiais do texto
        const textoLimpo = texto.replace(/[🌟🏆💪🧠❤️✨🎯🌈]/g, "").trim();

        const utterance = new SpeechSynthesisUtterance(textoLimpo);
        utterance.lang = "pt-BR";
        utterance.rate = opcoes.rate || 0.9; // Velocidade
        utterance.pitch = opcoes.pitch || 1.0; // Tom de voz
        utterance.volume = opcoes.volume || 0.8; // Volume

        // Usar voz selecionada se disponível
        if (vozSelecionada) {
          utterance.voice = vozSelecionada;
        }

        // Callbacks opcionais
        if (opcoes.onEnd) {
          utterance.onend = opcoes.onEnd;
        }
        if (opcoes.onError) {
          utterance.onerror = opcoes.onError;
        }

        window.speechSynthesis.speak(utterance);
      }

      // Parar fala
      function pararFala() {
        window.speechSynthesis.cancel();
      }

      // Falar pergunta com voz de criança (pitch mais alto)
      function falarPergunta(textoPergunta) {
        const pitch = personagemEscolhido === "menino" ? 1.3 : 1.1;
        falarTexto(textoPergunta, { pitch, rate: 0.85 });
      }

      // Falar feedback com emoção
      function falarFeedback(textoFeedback, isPositivo = true) {
        const pitch = isPositivo ? 1.2 : 0.9;
        const rate = isPositivo ? 1.0 : 0.85;
        falarTexto(textoFeedback, { pitch, rate });
      }

      // Carregar configurações das perguntas do JSONBin ou arquivo local
      async function carregarPerguntas() {
        try {
          console.log("Tentando carregar do JSONBin...");

          // Tentar carregar do JSONBin primeiro
          const response = await fetch(JSONBIN_URL);
          if (!response.ok) {
            throw new Error(`JSONBin error! status: ${response.status}`);
          }

          const data = await response.json();

          // JSONBin retorna os dados dentro de 'record'
          const perguntasData = data.record || data;

          if (
            perguntasData.perguntas &&
            Array.isArray(perguntasData.perguntas)
          ) {
            perguntasConfig = perguntasData.perguntas;
            document.getElementById("total-questions").textContent =
              perguntasConfig.length;

            console.log(
              `✅ ${perguntasConfig.length} perguntas carregadas do JSONBin!`
            );

            // Esconder overlay invisível e mostrar primeira pergunta
            document.getElementById("invisible-loader").style.display = "none";
            mostrarPergunta(0);
          } else {
            throw new Error("Formato JSON inválido no JSONBin");
          }
        } catch (error) {
          console.warn("Erro ao carregar do JSONBin:", error.message);
          console.log("Tentando carregar arquivo local...");

          // Se falhar, usar o seletor de arquivo como fallback
          carregarArquivoLocal();
        }
      }

      // Fallback: carregar arquivo local
      function carregarArquivoLocal() {
        // Simular clique no input file para abrir seletor
        const fileInput = document.getElementById("json-file-input");
        fileInput.click();
      }

      // Processar arquivo JSON selecionado
      function processarArquivoJSON(file) {
        if (!file.name.toLowerCase().endsWith(".json")) {
          document.getElementById("question-text").textContent =
            "Erro: Selecione um arquivo JSON";
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = JSON.parse(e.target.result);

            if (data.perguntas && Array.isArray(data.perguntas)) {
              const perguntasValidas = data.perguntas.every(
                (p) =>
                  p.id &&
                  p.pergunta &&
                  p.resposta_correta &&
                  p.rectangle1_background_color &&
                  p.rectangle2_background_color &&
                  p.ilustracao
                // opcoes agora é opcional
              );

              if (perguntasValidas) {
                perguntasConfig = data.perguntas;
                document.getElementById("total-questions").textContent =
                  perguntasConfig.length;

                // Esconder overlay invisível e mostrar primeira pergunta
                document.getElementById("invisible-loader").style.display =
                  "none";
                mostrarPergunta(0);
              } else {
                document.getElementById("question-text").textContent =
                  "Erro: Estrutura do JSON inválida";
              }
            } else {
              document.getElementById("question-text").textContent =
                "Erro: JSON deve conter 'perguntas'";
            }
          } catch (error) {
            document.getElementById("question-text").textContent =
              "Erro ao processar JSON: " + error.message;
          }
        };

        reader.onerror = function () {
          document.getElementById("question-text").textContent =
            "Erro ao ler o arquivo";
        };

        reader.readAsText(file);
      }

      // Atualizar personagem na sidebar
      function atualizarPersonagemSidebar(emocao = "normal") {
        const characterSidebar = document.getElementById("character-sidebar");
        const imagemPersonagem = `url('../recursos/imagens/personagens/${personagemEscolhido}_${emocao}.png')`;
        characterSidebar.style.backgroundImage = imagemPersonagem;
      }

      // Verificar se deve mostrar motivação e conceder selo
      function verificarMotivacaoESelo() {
        // Recalcular perguntas únicas baseado no gameProgress atualizado
        const gameData = JSON.parse(
          localStorage.getItem("gameProgress") || "[]"
        );
        const perguntasUnicas = gameData.length;

        // A cada 5 perguntas únicas respondidas
        if (perguntasUnicas > 0 && perguntasUnicas % 5 === 0) {
          const numeroSelo = Math.floor(perguntasUnicas / 5);

          // Verificar se já conquistou este selo
          const seloJaConquistado = selosConquistados.some(
            (selo) => selo.id === numeroSelo
          );

          if (!seloJaConquistado) {
            const fraseMotivacional =
              frasesMotivacionais[
                (numeroSelo - 1) % frasesMotivacionais.length
              ];

            // Conceder selo
            const novoSelo = {
              id: numeroSelo,
              nome: `Selo ${numeroSelo}`,
              descricao: `Conquistado após ${perguntasUnicas} perguntas únicas respondidas`,
              icone: "🏅",
              dataConquista: new Date().toISOString(),
            };

            selosConquistados.push(novoSelo);

            // Salvar selos no localStorage
            localStorage.setItem(
              "selosConquistados",
              JSON.stringify(selosConquistados)
            );

            // Mostrar motivação com selo
            const mensagemCompleta = `${fraseMotivacional}\n\n🏅 Você ganhou um novo selo!\n"${novoSelo.nome}"`;

            mostrarBalaoFala(mensagemCompleta, "feliz", () => {
              // Continuar com a próxima pergunta
              aguardandoProximaPergunta = false;
              perguntaAtual++;
              mostrarPergunta(perguntaAtual);
            });

            return true; // Indica que foi mostrada motivação
          }
        }

        return false; // Não foi mostrada motivação
      }

      // Função para falar a pergunta (preparada para áudios futuros)
      function falarPergunta() {
        if (
          perguntasConfig.length === 0 ||
          perguntaAtual >= perguntasConfig.length
        ) {
          return;
        }

        const pergunta = perguntasConfig[perguntaAtual];

        // Animar personagem falando
        atualizarPersonagemSidebar("feliz");

        // ========== ÁUDIO PERSONALIZADO COM VOZES DE CRIANÇA (IA) ==========
        // TODO: Implementação futura de falas personalizadas geradas por IA
        // Cada pergunta terá seu próprio arquivo de áudio com voz de criança real
        // Arquivos esperados: src/recursos/audio/falas/01.ogg, 02.ogg, etc.
        // 
        // Exemplo de implementação:
        // if (perguntaAtual === 0) {
        //   const audio = new Audio("../recursos/audio/falas/01.ogg");
        //   audio.play();
        // }
        // 
        // Quando implementar, descomentar e estender para todas as perguntas:
        // const audioFala = new Audio(`../recursos/audio/falas/${String(perguntaAtual + 1).padStart(2, '0')}.ogg`);
        // audioFala.play().catch(err => console.log('Áudio personalizado não disponível, usando TTS'));
        // ==================================================================

        // Mostrar balão de fala com a pergunta
        mostrarBalaoFala(pergunta.pergunta, "normal", () => {
          atualizarPersonagemSidebar("normal");
        });

        // Voltar ao normal após 3 segundos
        setTimeout(() => {
          atualizarPersonagemSidebar("normal");
        }, 3000);
      }

      // Mostrar balão de fala com personagem
      function mostrarBalaoFala(texto, emocao = "normal", callback = null) {
        const overlay = document.getElementById("speech-overlay");
        const characterImage = document.getElementById("character-image");
        const speechText = document.getElementById("speech-text");

        // Definir imagem do personagem baseada na emoção
        const imagemPersonagem = `url('../recursos/imagens/personagens/${personagemEscolhido}_${emocao}.png')`;
        characterImage.style.backgroundImage = imagemPersonagem;

        // Definir texto e estilo
        speechText.textContent = texto;
        speechText.className = "speech-text";
        if (emocao === "feliz") {
          speechText.classList.add("success");
        } else if (emocao === "triste") {
          speechText.classList.add("error");
        }

        // Mostrar overlay
        overlay.style.display = "flex";

        // 🎤 FALAR FEEDBACK com emoção
        const isPositivo = emocao === "feliz";
        setTimeout(() => {
          falarFeedback(texto, isPositivo);
        }, 200);

        // Função para fechar o balão
        function fecharBalao() {
          overlay.style.display = "none";
          overlay.onclick = null; // Remover listener de clique
          document.removeEventListener("keydown", handleKeyDown); // Remover listener de tecla
          pararFala(); // Parar qualquer fala em andamento
          if (callback) {
            callback();
          }
        }

        // Função para lidar com teclas
        function handleKeyDown(event) {
          if (event.key === "Enter") {
            event.preventDefault(); // Impede o comportamento padrão do Enter
            event.stopPropagation(); // Impede que o evento se propague
            fecharBalao();
          }
        }

        // Configurar clique para fechar
        overlay.onclick = fecharBalao;

        // Configurar Enter para fechar
        document.addEventListener("keydown", handleKeyDown);
      }

      // Mostrar pergunta específica
      function mostrarPergunta(index) {
        if (index >= perguntasConfig.length) {
          mostrarResultadoFinal();
          return;
        }

        const pergunta = perguntasConfig[index];
        perguntaAtual = index;

        // Atualizar contador
        document.getElementById("current-question").textContent = index + 1;

        // Atualizar conteúdo
        document.getElementById("question-text").textContent =
          pergunta.pergunta;

        // Usar textos personalizados das opções ou padrão "SIM" e "NÃO"
        const textoPositivo = pergunta.opcoes?.sim || "SIM";
        const textoNegativo = pergunta.opcoes?.nao || "NÃO";

        document.getElementById("positive-answer-text").textContent =
          textoPositivo;
        document.getElementById("negative-answer-text").textContent =
          textoNegativo;

        // Atualizar cores
        const mainContainer = document.getElementById(
          "main-question-container"
        );
        const backgroundContainer = document.getElementById(
          "background-question-container"
        );

        mainContainer.style.backgroundColor =
          pergunta.rectangle1_background_color;
        backgroundContainer.style.backgroundColor =
          pergunta.rectangle2_background_color;

        // Atualizar ilustração
        const illustration = document.getElementById("question-illustration");
        illustration.style.backgroundImage = `url('../recursos/imagens/ilustracoes/${pergunta.ilustracao}')`;

        // Atualizar personagem
        atualizarPersonagemSidebar("normal");

        // Adicionar animação
        const content = document.getElementById("main-content");
        content.classList.add("fade-transition");
        setTimeout(() => {
          content.classList.add("show");

          // 🎤 FALAR PERGUNTA AUTOMATICAMENTE após animação
          setTimeout(() => {
            falarPergunta(pergunta.pergunta);
          }, 300);
        }, 100);
      }

      // Processar resposta
      function processarResposta(resposta) {
        if (aguardandoProximaPergunta) return; // Evitar cliques múltiplos

        const pergunta = perguntasConfig[perguntaAtual];
        totalAttempts++;

        // Sempre incrementar o total de perguntas respondidas
        perguntasRespondidas++;

        // Verificar se é uma pergunta nova (única) para os selos
        const gameData = JSON.parse(
          localStorage.getItem("gameProgress") || "[]"
        );
        const perguntaJaRespondida = gameData.some(
          (item) => item.pergunta === pergunta.id
        );

        // Só incrementar perguntas únicas se for pergunta nova
        if (!perguntaJaRespondida) {
          perguntasUnicas++;
        }
        aguardandoProximaPergunta = true;

        const acertou = resposta === pergunta.resposta_correta;

        if (acertou) {
          pontuacao++;

          // Verificar se deve mostrar motivação e selo
          const mostroumotivacao = verificarMotivacaoESelo();

          if (!mostroumotivacao) {
            // Mostrar balão normal se não houve motivação
            mostrarBalaoFala("Escolha correta! 🎉", "feliz", () => {
              aguardandoProximaPergunta = false;
              perguntaAtual++;
              mostrarPergunta(perguntaAtual);
            });
          }
        } else {
          // Verificar se deve mostrar motivação e selo mesmo com erro
          const mostroumotivacao = verificarMotivacaoESelo();

          if (!mostroumotivacao) {
            // Mostrar balão normal se não houve motivação
            mostrarBalaoFala(
              "Ops! Tente pensar melhor na próxima! 🤔",
              "triste",
              () => {
                aguardandoProximaPergunta = false;
                perguntaAtual++;
                mostrarPergunta(perguntaAtual);
              }
            );
          }
        }

        // Salvar progresso
        updateGameProgress(
          pergunta.id,
          resposta === "sim" ? 1 : 0,
          totalAttempts
        );

        // Salvar contador de perguntas respondidas
        localStorage.setItem(
          "perguntasRespondidas",
          perguntasRespondidas.toString()
        );
      }

      // Mostrar resultado final
      function mostrarResultadoFinal() {
        // Salvar resultado final
        const resultadoFinal = {
          acertos: pontuacao,
          total: perguntasConfig.length,
          percentual: Math.round((pontuacao / perguntasConfig.length) * 100),
          tentativas: totalAttempts,
        };

        localStorage.setItem("finalScore", JSON.stringify(resultadoFinal));

        // Mostrar mensagem final com personagem
        const percentual = resultadoFinal.percentual;
        let mensagem, emocao;

        if (percentual >= 70) {
          mensagem = "🎉 Parabéns! Você foi incrível! 🎉";
          emocao = "feliz";
        } else if (percentual >= 50) {
          mensagem = "😊 Bom trabalho! Você pode melhorar! 😊";
          emocao = "normal";
        } else {
          mensagem = "🤔 Continue tentando! Você vai conseguir! 🤔";
          emocao = "triste";
        }

        mostrarBalaoFala(mensagem, emocao, () => {
          // Redirecionar para a tela de resultados após clique
          window.location.href = "resultados.html";
        });
      }

      // Funções de áudio (mantidas do original)
      function setVolumeIcon(isMuted) {
        document.getElementById("vol-icon").textContent = isMuted
          ? "volume_off"
          : "volume_up";
      }

      function syncBGMusicWithState() {
        const audio = document.getElementById("bg-music");
        const muted = localStorage.getItem("bgMusicMuted") === "1";
        setVolumeIcon(muted);
        audio.volume = 0.3;
        audio.muted = muted;
        if (!muted && window.__musicStarted) {
          audio.play().catch(() => {});
        } else {
          audio.pause();
        }
      }

      function updateGameProgress(question, answer, attempts) {
        let gameData = JSON.parse(localStorage.getItem("gameProgress")) || [];
        let existingQuestionIndex = gameData.findIndex(
          (item) => item.pergunta === question
        );

        if (existingQuestionIndex === -1) {
          gameData.push({
            pergunta: question,
            resposta: answer,
            quantidade: attempts,
          });
        } else {
          gameData[existingQuestionIndex] = {
            pergunta: question,
            resposta: answer,
            quantidade: attempts,
          };
        }
        localStorage.setItem("gameProgress", JSON.stringify(gameData));
      }

      // Event Listeners
      document.addEventListener("DOMContentLoaded", function () {
        // Carregar personagem escolhido (padrão: menino)
        personagemEscolhido =
          localStorage.getItem("personagemEscolhido") ||
          localStorage.getItem("selectedCharacter") ||
          "menino";

        // Carregar selos conquistados do localStorage
        const selosSalvos = localStorage.getItem("selosConquistados");
        if (selosSalvos) {
          selosConquistados = JSON.parse(selosSalvos);
        }

        // Carregar contadores de perguntas
        // Total de perguntas respondidas (incluindo repetidas)
        const perguntasSalvas = localStorage.getItem("perguntasRespondidas");
        if (perguntasSalvas) {
          perguntasRespondidas = parseInt(perguntasSalvas) || 0;
        }

        // Perguntas únicas baseadas no gameProgress
        const gameData = JSON.parse(
          localStorage.getItem("gameProgress") || "[]"
        );
        perguntasUnicas = gameData.length; // Cada item no gameProgress é uma pergunta única

        // Configurar personagem na sidebar
        atualizarPersonagemSidebar("normal");

        // Mostrar texto "Carregando..." e overlay invisível
        document.getElementById("question-text").textContent = "Carregando...";
        const invisibleLoader = document.getElementById("invisible-loader");
        invisibleLoader.style.display = "block";

        // Configurar input file
        const fileInput = document.getElementById("json-file-input");
        fileInput.addEventListener("change", function (e) {
          if (e.target.files.length > 0) {
            processarArquivoJSON(e.target.files[0]);
          }
        });

        // Configurar clique no overlay invisível para carregar JSON
        invisibleLoader.addEventListener("click", function () {
          carregarPerguntas();
        });

        // Configurar áudio
        const audio = document.getElementById("bg-music");
        audio.volume = 0.3;
        audio.muted = localStorage.getItem("bgMusicMuted") === "1";
        setVolumeIcon(audio.muted);

        // Botão de controle de volume
        document
          .getElementById("volumeBtn")
          .addEventListener("click", function () {
            const currentlyMuted = localStorage.getItem("bgMusicMuted") === "1";
            localStorage.setItem("bgMusicMuted", currentlyMuted ? "0" : "1");
            syncBGMusicWithState();
            if (!currentlyMuted) {
              window.__musicStarted = true;
              syncBGMusicWithState();
            }
          });

        // Botão de fala da pergunta - Repetir pergunta atual
        document
          .getElementById("question-audio-btn")
          .addEventListener("click", function () {
            if (perguntaAtual >= 0 && perguntaAtual < perguntasConfig.length) {
              const pergunta = perguntasConfig[perguntaAtual];
              falarPergunta(pergunta.pergunta);
            }
          });

        // Botões de resposta
        document
          .getElementById("positive-answer-btn")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            if (!aguardandoProximaPergunta) {
              processarResposta("sim");
            }
          });
        document
          .getElementById("negative-answer-btn")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            if (!aguardandoProximaPergunta) {
              processarResposta("nao");
            }
          });

        // Iniciar música após interação
        function tryPlayMusicAfterInteraction() {
          if (localStorage.getItem("bgMusicMuted") === "0") {
            window.__musicStarted = true;
            syncBGMusicWithState();
          }
          document.body.removeEventListener(
            "click",
            tryPlayMusicAfterInteraction
          );
        }
        document.body.addEventListener("click", tryPlayMusicAfterInteraction);

        // Configurar overlay invisível para fullscreen
        const fullscreenOverlay = document.getElementById("fullscreen-overlay");
        if (fullscreenOverlay && localStorage.getItem("fullscreen") === "1") {
          fullscreenOverlay.style.display = "block";
          fullscreenOverlay.onclick = function () {
            document.documentElement
              .requestFullscreen()
              .then(() => {
                fullscreenOverlay.style.display = "none";
              })
              .catch(console.warn);
          };
        }
      });
    </script>
  </body>
</html>
